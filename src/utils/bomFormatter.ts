import type {
  UnitSystem,
  ImperialFormat,
  GridSpacerConfig,
  SpacerMode,
  BOMItem,
  PlacedItem,
  LibraryItem,
  Rotation,
} from '../types/gridfinity';

export interface GridSummaryData {
  gridX: number;
  gridY: number;
  width: number;
  depth: number;
  unit: UnitSystem;
  imperialFormat: ImperialFormat;
  gapWidth: number;
  gapDepth: number;
  spacerConfig: GridSpacerConfig;
}

export interface GridLayoutExport {
  version: string;
  exportedAt: string;
  generator: string;
  grid: {
    gridX: number;
    gridY: number;
    width: number;
    depth: number;
    unit: UnitSystem;
    gapWidth: number;
    gapDepth: number;
  };
  spacers: {
    horizontal: SpacerMode;
    vertical: SpacerMode;
  };
  items: Array<{
    itemId: string;
    name: string;
    x: number;
    y: number;
    width: number;
    height: number;
    rotation: Rotation;
  }>;
  bom: Array<{
    itemId: string;
    name: string;
    widthUnits: number;
    heightUnits: number;
    quantity: number;
  }>;
  notes: string;
}

export type LibraryNameMap = ReadonlyMap<string, string>;

const GENERATOR_NAME = 'Gridfinity Bin Customizer';
const EXPORT_VERSION = '1.0.0';
const REFERENCE_IMAGE_NOTE = 'Reference images are not included in this export.';

function formatPartId(prefixedId: string, libraryNames: LibraryNameMap): string {
  const colonIndex = prefixedId.indexOf(':');
  if (colonIndex === -1) return prefixedId;
  const libraryId = prefixedId.slice(0, colonIndex);
  const partId = prefixedId.slice(colonIndex + 1);
  const libraryName = libraryNames.get(libraryId) ?? libraryId;
  return `${libraryName}/${partId}`;
}

export function formatBOMSubjectLine(gridX: number, gridY: number, totalItems: number): string {
  return `Gridfinity Layout â€” ${gridX}x${gridY} Grid, ${totalItems} Items`;
}

export function formatBOMEmailBody(summary: GridSummaryData, items: BOMItem[], libraryNames: LibraryNameMap): string {
  const unitLabel = summary.unit === 'metric' ? 'mm' : 'in';
  const totalQuantity = items.reduce((sum, item) => sum + item.quantity, 0);
  const totalUnique = items.length;

  const formatDim = (value: number): string => {
    if (summary.unit === 'metric') return value.toFixed(1);
    return value.toFixed(2);
  };

  let body = `GRIDFINITY LAYOUT SPECIFICATION\n`;
  body += `================================\n\n`;

  body += `GRID SUMMARY\n`;
  body += `  Grid Size:    ${summary.gridX} x ${summary.gridY} units\n`;
  body += `  Dimensions:   ${formatDim(summary.width)} x ${formatDim(summary.depth)} ${unitLabel}\n`;
  body += `  Horizontal:   ${formatDim(summary.gapWidth)} ${unitLabel} gap, ${summary.spacerConfig.horizontal} spacer\n`;
  body += `  Vertical:     ${formatDim(summary.gapDepth)} ${unitLabel} gap, ${summary.spacerConfig.vertical} spacer\n\n`;

  body += `BILL OF MATERIALS (${totalUnique} unique, ${totalQuantity} total)\n`;

  if (items.length > 0) {
    body += `  Qty  Size    ID                   Name\n`;
    body += `  ---  ------  -------------------  --------------------\n`;
    for (const item of items) {
      const qty = `x${item.quantity}`.padEnd(3);
      const size = `${item.widthUnits}x${item.heightUnits}`.padEnd(6);
      const displayId = formatPartId(item.itemId, libraryNames);
      const id = displayId.padEnd(19);
      body += `  ${qty}  ${size}  ${id}  ${item.name}\n`;
    }
  }

  body += `\nNOTES\n`;
  body += `  - A JSON layout file has been downloaded separately.\n`;
  body += `    Please attach it to this email.\n`;
  body += `  - ${REFERENCE_IMAGE_NOTE}\n`;
  body += `  - Generated by ${GENERATOR_NAME}\n`;

  return body;
}

export function buildLayoutExport(
  summary: GridSummaryData,
  placedItems: PlacedItem[],
  bomItems: BOMItem[],
  getItemById: (id: string) => LibraryItem | undefined,
  libraryNames: LibraryNameMap,
): GridLayoutExport {
  const items = placedItems
    .map(placed => {
      const lib = getItemById(placed.itemId);
      if (!lib) return null;
      return {
        itemId: formatPartId(placed.itemId, libraryNames),
        name: lib.name,
        x: placed.x,
        y: placed.y,
        width: placed.width,
        height: placed.height,
        rotation: placed.rotation,
      };
    })
    .filter((item): item is NonNullable<typeof item> => item !== null);

  const bom = bomItems.map(item => ({
    itemId: formatPartId(item.itemId, libraryNames),
    name: item.name,
    widthUnits: item.widthUnits,
    heightUnits: item.heightUnits,
    quantity: item.quantity,
  }));

  return {
    version: EXPORT_VERSION,
    exportedAt: new Date().toISOString(),
    generator: GENERATOR_NAME,
    grid: {
      gridX: summary.gridX,
      gridY: summary.gridY,
      width: summary.width,
      depth: summary.depth,
      unit: summary.unit,
      gapWidth: summary.gapWidth,
      gapDepth: summary.gapDepth,
    },
    spacers: {
      horizontal: summary.spacerConfig.horizontal,
      vertical: summary.spacerConfig.vertical,
    },
    items,
    bom,
    notes: REFERENCE_IMAGE_NOTE,
  };
}
